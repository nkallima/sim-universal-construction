<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The Synch framework: lcrq.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_synch.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The Synch framework
   &#160;<span id="projectnumber">v2.5.0</span>
   </div>
   <div id="projectbrief">An open-source framework for concurrent data-structures and benchmarks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_bba3cddd56565a95b77b098fd409d0ab.html">libconcurrent</a></li><li class="navelem"><a class="el" href="dir_3b0504cce330a6e867091f76f8160def.html">includes</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lcrq.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a slightly modified version of the LCRQ queue implementation by Adam Morrison and Yehuda Afek provided in <a href="http://mcg.cs.tau.ac.il/projects/lcrq">http://mcg.cs.tau.ac.il/projects/lcrq</a>.  
<a href="#details">More...</a></p>

<p><a href="lcrq_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structRingNode"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lcrq_8h.html#structRingNode">RingNode</a></td></tr>
<tr class="separator:structRingNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structRingQueue"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lcrq_8h.html#structRingQueue">RingQueue</a></td></tr>
<tr class="separator:structRingQueue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structLCRQStruct"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lcrq_8h.html#structLCRQStruct">LCRQStruct</a></td></tr>
<tr class="memdesc:structLCRQStruct"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="lcrq_8h.html#structLCRQStruct" title="LCRQStruct stores the state of an instance of the LCRQ concurrent queue implementation....">LCRQStruct</a> stores the state of an instance of the LCRQ concurrent queue implementation. <a class="el" href="lcrq_8h.html#structLCRQStruct" title="LCRQStruct stores the state of an instance of the LCRQ concurrent queue implementation....">LCRQStruct</a> should be initialized using the LCRQStructInit function.  <a href="lcrq_8h.html#structLCRQStruct">More...</a><br /></td></tr>
<tr class="separator:structLCRQStruct"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structLCRQThreadState"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lcrq_8h.html#structLCRQThreadState">LCRQThreadState</a></td></tr>
<tr class="memdesc:structLCRQThreadState"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="lcrq_8h.html#structLCRQThreadState" title="LCRQThreadState stores each thread&#39;s local state for a single instance of LCRQ. For each instance of ...">LCRQThreadState</a> stores each thread's local state for a single instance of LCRQ. For each instance of LCRQ, a discrete instance of <a class="el" href="lcrq_8h.html#structLCRQThreadState" title="LCRQThreadState stores each thread&#39;s local state for a single instance of LCRQ. For each instance of ...">LCRQThreadState</a> should be used.  <a href="lcrq_8h.html#structLCRQThreadState">More...</a><br /></td></tr>
<tr class="separator:structLCRQThreadState"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac7f4102deddc15a31e3e0b2dd925ef35"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lcrq_8h.html#ac7f4102deddc15a31e3e0b2dd925ef35">RING_POW</a>&#160;&#160;&#160;(14)</td></tr>
<tr class="separator:ac7f4102deddc15a31e3e0b2dd925ef35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1581e7fe155ec30aa3e34788936e6c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lcrq_8h.html#a1d1581e7fe155ec30aa3e34788936e6c">RING_SIZE</a>&#160;&#160;&#160;(1ULL &lt;&lt; <a class="el" href="lcrq_8h.html#ac7f4102deddc15a31e3e0b2dd925ef35">RING_POW</a>)</td></tr>
<tr class="separator:a1d1581e7fe155ec30aa3e34788936e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3e5d1c8978fdd6faf21fc73468993741"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lcrq_8h.html#a3e5d1c8978fdd6faf21fc73468993741">LCRQInit</a> (<a class="el" href="lcrq_8h.html#structLCRQStruct">LCRQStruct</a> *queue, uint32_t nthreads)</td></tr>
<tr class="memdesc:a3e5d1c8978fdd6faf21fc73468993741"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes an instance of the LCRQ concurrent queue implementation. This function should be called once (by a single thread) before any other thread tries to apply any enqueue or dequeue operation.  <a href="lcrq_8h.html#a3e5d1c8978fdd6faf21fc73468993741">More...</a><br /></td></tr>
<tr class="separator:a3e5d1c8978fdd6faf21fc73468993741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5a3ba9ef4e61fe726d26775ee42d1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lcrq_8h.html#a6b5a3ba9ef4e61fe726d26775ee42d1d">LCRQThreadStateInit</a> (<a class="el" href="lcrq_8h.html#structLCRQThreadState">LCRQThreadState</a> *thread_state, int pid)</td></tr>
<tr class="memdesc:a6b5a3ba9ef4e61fe726d26775ee42d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called once before the thread applies any operation to the LCRQ concurrent queue implementation.  <a href="lcrq_8h.html#a6b5a3ba9ef4e61fe726d26775ee42d1d">More...</a><br /></td></tr>
<tr class="separator:a6b5a3ba9ef4e61fe726d26775ee42d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae343585a3d04de1e4779cbd851f0ef47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lcrq_8h.html#ae343585a3d04de1e4779cbd851f0ef47">LCRQEnqueue</a> (<a class="el" href="lcrq_8h.html#structLCRQStruct">LCRQStruct</a> *queue, <a class="el" href="lcrq_8h.html#structLCRQThreadState">LCRQThreadState</a> *thread_state, ArgVal arg, int pid)</td></tr>
<tr class="memdesc:ae343585a3d04de1e4779cbd851f0ef47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds (i.e. enqueues) a new element to the back of the queue. This element has a value equal with arg.  <a href="lcrq_8h.html#ae343585a3d04de1e4779cbd851f0ef47">More...</a><br /></td></tr>
<tr class="separator:ae343585a3d04de1e4779cbd851f0ef47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7058a6a57b5154e41320dc87a2ba2a6"><td class="memItemLeft" align="right" valign="top">RetVal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lcrq_8h.html#ad7058a6a57b5154e41320dc87a2ba2a6">LCRQDequeue</a> (<a class="el" href="lcrq_8h.html#structLCRQStruct">LCRQStruct</a> *queue, <a class="el" href="lcrq_8h.html#structLCRQThreadState">LCRQThreadState</a> *thread_state, int pid)</td></tr>
<tr class="memdesc:ad7058a6a57b5154e41320dc87a2ba2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function removes (i.e. dequeues) an element from the front of the queue and returns its value.  <a href="lcrq_8h.html#ad7058a6a57b5154e41320dc87a2ba2a6">More...</a><br /></td></tr>
<tr class="separator:ad7058a6a57b5154e41320dc87a2ba2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a slightly modified version of the LCRQ queue implementation by Adam Morrison and Yehuda Afek provided in <a href="http://mcg.cs.tau.ac.il/projects/lcrq">http://mcg.cs.tau.ac.il/projects/lcrq</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Adam Morrison and Yehuda Afek</dd></dl>
<p>LCRQ is presented in "Fast concurrent queues for x86 processors", by Adam Morrison, and Yehuda Afek, in PPoPP 2013. This modified version has some minor modifications in order to be compatible with the latest version of the Synch framework. Notice that this algorithm performs exceptionally well in X86 machines that natively support 128-bit Compare&amp;Swap instructions. It is also tested in ARM-V8 and in RISCV machines. This modified version seems to have very similar performance as the original one. The original version of LCRQ is distributed under the New BSD Licence (LGPL-2.1 is compatible with New BSD Licence, more on <a href="https://www.gnu.org/licenses/license-compatibility.html">https://www.gnu.org/licenses/license-compatibility.html</a>). </p><dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2021 </dd></dl>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structRingNode" id="structRingNode"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structRingNode">&#9670;&nbsp;</a></span>RingNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct RingNode</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a80df4b31f20461c4cd30f91c3bb45be6"></a>volatile uint64_t</td>
<td class="fieldname">
val</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a09c77c99e969b6d7da9dced921e1271c"></a>volatile uint64_t</td>
<td class="fieldname">
idx</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a067fa2e295cb696744fabf47170910e1"></a>char</td>
<td class="fieldname">
pad[PAD_CACHE(2 *sizeof(uint64_t))]</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structRingQueue" id="structRingQueue"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structRingQueue">&#9670;&nbsp;</a></span>RingQueue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct RingQueue</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div>
</div>
</div>
<a name="structLCRQStruct" id="structLCRQStruct"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structLCRQStruct">&#9670;&nbsp;</a></span>LCRQStruct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct LCRQStruct</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p><a class="el" href="lcrq_8h.html#structLCRQStruct" title="LCRQStruct stores the state of an instance of the LCRQ concurrent queue implementation....">LCRQStruct</a> stores the state of an instance of the LCRQ concurrent queue implementation. <a class="el" href="lcrq_8h.html#structLCRQStruct" title="LCRQStruct stores the state of an instance of the LCRQ concurrent queue implementation....">LCRQStruct</a> should be initialized using the LCRQStructInit function. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aa343323c1f1f383d9ce9dd92e71eae4d"></a><a class="el" href="lcrq_8h.html#structRingQueue">RingQueue</a> *</td>
<td class="fieldname">
head</td>
<td class="fielddoc">
A pointer to the head Ring. </td></tr>
<tr><td class="fieldtype">
<a id="a06e622fd34b5b198de3d04507f94c575"></a><a class="el" href="lcrq_8h.html#structRingQueue">RingQueue</a> *</td>
<td class="fieldname">
tail</td>
<td class="fielddoc">
A pointer to the tail Ring. </td></tr>
</table>

</div>
</div>
<a name="structLCRQThreadState" id="structLCRQThreadState"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structLCRQThreadState">&#9670;&nbsp;</a></span>LCRQThreadState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct LCRQThreadState</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p><a class="el" href="lcrq_8h.html#structLCRQThreadState" title="LCRQThreadState stores each thread&#39;s local state for a single instance of LCRQ. For each instance of ...">LCRQThreadState</a> stores each thread's local state for a single instance of LCRQ. For each instance of LCRQ, a discrete instance of <a class="el" href="lcrq_8h.html#structLCRQThreadState" title="LCRQThreadState stores each thread&#39;s local state for a single instance of LCRQ. For each instance of ...">LCRQThreadState</a> should be used. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="adea0a6f7ebebef428ca33636756a7cb2"></a><a class="el" href="lcrq_8h.html#structRingQueue">RingQueue</a> *</td>
<td class="fieldname">
nrq</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac7f4102deddc15a31e3e0b2dd925ef35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f4102deddc15a31e3e0b2dd925ef35">&#9670;&nbsp;</a></span>RING_POW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RING_POW&#160;&#160;&#160;(14)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d1581e7fe155ec30aa3e34788936e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1581e7fe155ec30aa3e34788936e6c">&#9670;&nbsp;</a></span>RING_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RING_SIZE&#160;&#160;&#160;(1ULL &lt;&lt; <a class="el" href="lcrq_8h.html#ac7f4102deddc15a31e3e0b2dd925ef35">RING_POW</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3e5d1c8978fdd6faf21fc73468993741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5d1c8978fdd6faf21fc73468993741">&#9670;&nbsp;</a></span>LCRQInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LCRQInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lcrq_8h.html#structLCRQStruct">LCRQStruct</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nthreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes an instance of the LCRQ concurrent queue implementation. This function should be called once (by a single thread) before any other thread tries to apply any enqueue or dequeue operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>A pointer to an instance of the LCRQ concurrent queue implementation. </td></tr>
    <tr><td class="paramname">nthreads</td><td>The number of threads that will use the LCRQ concurrent queue implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b5a3ba9ef4e61fe726d26775ee42d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5a3ba9ef4e61fe726d26775ee42d1d">&#9670;&nbsp;</a></span>LCRQThreadStateInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LCRQThreadStateInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lcrq_8h.html#structLCRQThreadState">LCRQThreadState</a> *&#160;</td>
          <td class="paramname"><em>thread_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be called once before the thread applies any operation to the LCRQ concurrent queue implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_state</td><td>A pointer to thread's local state of LCRQ. </td></tr>
    <tr><td class="paramname">pid</td><td>The pid of the calling thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae343585a3d04de1e4779cbd851f0ef47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae343585a3d04de1e4779cbd851f0ef47">&#9670;&nbsp;</a></span>LCRQEnqueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LCRQEnqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lcrq_8h.html#structLCRQStruct">LCRQStruct</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lcrq_8h.html#structLCRQThreadState">LCRQThreadState</a> *&#160;</td>
          <td class="paramname"><em>thread_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgVal&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds (i.e. enqueues) a new element to the back of the queue. This element has a value equal with arg. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>A pointer to an instance of the LCRQ concurrent queue implementation. </td></tr>
    <tr><td class="paramname">thread_state</td><td>A pointer to thread's local state of LCRQ. </td></tr>
    <tr><td class="paramname">arg</td><td>The enqueue operation will insert a new element to the queue with value equal to arg. </td></tr>
    <tr><td class="paramname">pid</td><td>The pid of the calling thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7058a6a57b5154e41320dc87a2ba2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7058a6a57b5154e41320dc87a2ba2a6">&#9670;&nbsp;</a></span>LCRQDequeue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RetVal LCRQDequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lcrq_8h.html#structLCRQStruct">LCRQStruct</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lcrq_8h.html#structLCRQThreadState">LCRQThreadState</a> *&#160;</td>
          <td class="paramname"><em>thread_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function removes (i.e. dequeues) an element from the front of the queue and returns its value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>A pointer to an instance of the LCRQ concurrent queue implementation. </td></tr>
    <tr><td class="paramname">thread_state</td><td>A pointer to thread's local state of LCRQ. </td></tr>
    <tr><td class="paramname">pid</td><td>The pid of the calling thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the removed element. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
